/*
 * generated by Xtext 2.10.0
 */
package robot.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import robot.dSL.ANDexpression;
import robot.dSL.Behavior;
import robot.dSL.BehaviorName;
import robot.dSL.ColorLiteral;
import robot.dSL.DSLPackage;
import robot.dSL.DistanceLiteral;
import robot.dSL.EdgeLiteral;
import robot.dSL.EndAfter;
import robot.dSL.EndCondition;
import robot.dSL.EndWhen;
import robot.dSL.ExpressionBracket;
import robot.dSL.LeftMovementAction;
import robot.dSL.LeftRotatePoint;
import robot.dSL.MarsRoverExpedition;
import robot.dSL.MeasurementAction;
import robot.dSL.MiddleRotatePoint;
import robot.dSL.Mission;
import robot.dSL.MovementAction;
import robot.dSL.ORexpression;
import robot.dSL.RightMovementAction;
import robot.dSL.RightRotatePoint;
import robot.dSL.TouchLiteral;
import robot.services.DSLGrammarAccess;

@SuppressWarnings("all")
public class DSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DSLPackage.AN_DEXPRESSION:
				sequence_Expression1(context, (ANDexpression) semanticObject); 
				return; 
			case DSLPackage.BEHAVIOR:
				sequence_Behavior(context, (Behavior) semanticObject); 
				return; 
			case DSLPackage.BEHAVIOR_NAME:
				sequence_BehaviorName(context, (BehaviorName) semanticObject); 
				return; 
			case DSLPackage.COLOR_LITERAL:
				sequence_ColorLiteral(context, (ColorLiteral) semanticObject); 
				return; 
			case DSLPackage.DISTANCE_LITERAL:
				sequence_DistanceLiteral(context, (DistanceLiteral) semanticObject); 
				return; 
			case DSLPackage.EDGE_LITERAL:
				sequence_EdgeLiteral(context, (EdgeLiteral) semanticObject); 
				return; 
			case DSLPackage.END_AFTER:
				sequence_EndAfter(context, (EndAfter) semanticObject); 
				return; 
			case DSLPackage.END_CONDITION:
				sequence_EndCondition(context, (EndCondition) semanticObject); 
				return; 
			case DSLPackage.END_WHEN:
				sequence_EndWhen(context, (EndWhen) semanticObject); 
				return; 
			case DSLPackage.EXPRESSION_BRACKET:
				sequence_ExpressionBracket(context, (ExpressionBracket) semanticObject); 
				return; 
			case DSLPackage.LEFT_MOVEMENT_ACTION:
				sequence_LeftMovementAction(context, (LeftMovementAction) semanticObject); 
				return; 
			case DSLPackage.LEFT_ROTATE_POINT:
				if (rule == grammarAccess.getRotatePointsRule()
						|| rule == grammarAccess.getLeftRotatePointRule()) {
					sequence_LeftRotatePoint(context, (LeftRotatePoint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getActionsRule()
						|| rule == grammarAccess.getRotateMovementActionRule()) {
					sequence_LeftRotatePoint_RotateMovementAction(context, (LeftRotatePoint) semanticObject); 
					return; 
				}
				else break;
			case DSLPackage.MARS_ROVER_EXPEDITION:
				sequence_MarsRoverExpedition(context, (MarsRoverExpedition) semanticObject); 
				return; 
			case DSLPackage.MEASUREMENT_ACTION:
				sequence_MeasurementAction(context, (MeasurementAction) semanticObject); 
				return; 
			case DSLPackage.MIDDLE_ROTATE_POINT:
				if (rule == grammarAccess.getRotatePointsRule()
						|| rule == grammarAccess.getMiddleRotatePointRule()) {
					sequence_MiddleRotatePoint(context, (MiddleRotatePoint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getActionsRule()
						|| rule == grammarAccess.getRotateMovementActionRule()) {
					sequence_MiddleRotatePoint_RotateMovementAction(context, (MiddleRotatePoint) semanticObject); 
					return; 
				}
				else break;
			case DSLPackage.MISSION:
				sequence_Mission(context, (Mission) semanticObject); 
				return; 
			case DSLPackage.MOVEMENT_ACTION:
				sequence_MovementAction(context, (MovementAction) semanticObject); 
				return; 
			case DSLPackage.OREXPRESSION:
				sequence_Expression2(context, (ORexpression) semanticObject); 
				return; 
			case DSLPackage.RIGHT_MOVEMENT_ACTION:
				sequence_RightMovementAction(context, (RightMovementAction) semanticObject); 
				return; 
			case DSLPackage.RIGHT_ROTATE_POINT:
				if (rule == grammarAccess.getRotatePointsRule()
						|| rule == grammarAccess.getRightRotatePointRule()) {
					sequence_RightRotatePoint(context, (RightRotatePoint) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getActionsRule()
						|| rule == grammarAccess.getRotateMovementActionRule()) {
					sequence_RightRotatePoint_RotateMovementAction(context, (RightRotatePoint) semanticObject); 
					return; 
				}
				else break;
			case DSLPackage.TOUCH_LITERAL:
				sequence_TouchLiteral(context, (TouchLiteral) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BehaviorName returns BehaviorName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_BehaviorName(ISerializationContext context, BehaviorName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.BEHAVIOR_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.BEHAVIOR_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBehaviorNameAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Behavior returns Behavior
	 *
	 * Constraint:
	 *     (name=ID sensorExpression=Expression actionlist+=Actions+)
	 */
	protected void sequence_Behavior(ISerializationContext context, Behavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ColorLiteral
	 *     Expression1 returns ColorLiteral
	 *     Expression1.ANDexpression_1_0 returns ColorLiteral
	 *     Expression2 returns ColorLiteral
	 *     Expression2.ORexpression_1_0 returns ColorLiteral
	 *     Expression3 returns ColorLiteral
	 *     ColorLiteral returns ColorLiteral
	 *
	 * Constraint:
	 *     color=ColorEnum
	 */
	protected void sequence_ColorLiteral(ISerializationContext context, ColorLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.COLOR_LITERAL__COLOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.COLOR_LITERAL__COLOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColorLiteralAccess().getColorColorEnumEnumRuleCall_3_0(), semanticObject.getColor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DistanceLiteral
	 *     Expression1 returns DistanceLiteral
	 *     Expression1.ANDexpression_1_0 returns DistanceLiteral
	 *     Expression2 returns DistanceLiteral
	 *     Expression2.ORexpression_1_0 returns DistanceLiteral
	 *     Expression3 returns DistanceLiteral
	 *     DistanceLiteral returns DistanceLiteral
	 *
	 * Constraint:
	 *     distance=INT
	 */
	protected void sequence_DistanceLiteral(ISerializationContext context, DistanceLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.DISTANCE_LITERAL__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.DISTANCE_LITERAL__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDistanceLiteralAccess().getDistanceINTTerminalRuleCall_2_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EdgeLiteral
	 *     Expression1 returns EdgeLiteral
	 *     Expression1.ANDexpression_1_0 returns EdgeLiteral
	 *     Expression2 returns EdgeLiteral
	 *     Expression2.ORexpression_1_0 returns EdgeLiteral
	 *     Expression3 returns EdgeLiteral
	 *     EdgeLiteral returns EdgeLiteral
	 *
	 * Constraint:
	 *     edge=EdgeEnum
	 */
	protected void sequence_EdgeLiteral(ISerializationContext context, EdgeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.EDGE_LITERAL__EDGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.EDGE_LITERAL__EDGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEdgeLiteralAccess().getEdgeEdgeEnumEnumRuleCall_2_0(), semanticObject.getEdge());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EndCondition returns EndAfter
	 *     EndAfter returns EndAfter
	 *
	 * Constraint:
	 *     time=INT
	 */
	protected void sequence_EndAfter(ISerializationContext context, EndAfter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.END_AFTER__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.END_AFTER__TIME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndAfterAccess().getTimeINTTerminalRuleCall_1_0(), semanticObject.getTime());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EndCondition returns EndCondition
	 *
	 * Constraint:
	 *     endwhenlist+=EndWhen+
	 */
	protected void sequence_EndCondition(ISerializationContext context, EndCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EndWhen returns EndWhen
	 *
	 * Constraint:
	 *     (name=ID times=INT)
	 */
	protected void sequence_EndWhen(ISerializationContext context, EndWhen semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.END_WHEN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.END_WHEN__NAME));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.END_WHEN__TIMES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.END_WHEN__TIMES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndWhenAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEndWhenAccess().getTimesINTTerminalRuleCall_4_0(), semanticObject.getTimes());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ANDexpression
	 *     Expression1 returns ANDexpression
	 *     Expression1.ANDexpression_1_0 returns ANDexpression
	 *
	 * Constraint:
	 *     (left=Expression1_ANDexpression_1_0 right=Expression2)
	 */
	protected void sequence_Expression1(ISerializationContext context, ANDexpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.AN_DEXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.AN_DEXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.AN_DEXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.AN_DEXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression1Access().getANDexpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpression1Access().getRightExpression2ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ORexpression
	 *     Expression1 returns ORexpression
	 *     Expression1.ANDexpression_1_0 returns ORexpression
	 *     Expression2 returns ORexpression
	 *     Expression2.ORexpression_1_0 returns ORexpression
	 *
	 * Constraint:
	 *     (left=Expression2_ORexpression_1_0 right=Expression3)
	 */
	protected void sequence_Expression2(ISerializationContext context, ORexpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.OREXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.OREXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.OREXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.OREXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression2Access().getORexpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpression2Access().getRightExpression3ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionBracket
	 *     Expression1 returns ExpressionBracket
	 *     Expression1.ANDexpression_1_0 returns ExpressionBracket
	 *     Expression2 returns ExpressionBracket
	 *     Expression2.ORexpression_1_0 returns ExpressionBracket
	 *     Expression3 returns ExpressionBracket
	 *     ExpressionBracket returns ExpressionBracket
	 *
	 * Constraint:
	 *     exp=Expression
	 */
	protected void sequence_ExpressionBracket(ISerializationContext context, ExpressionBracket semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.EXPRESSION_BRACKET__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.EXPRESSION_BRACKET__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionBracketAccess().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actions returns LeftMovementAction
	 *     LeftMovementAction returns LeftMovementAction
	 *
	 * Constraint:
	 *     leftmove=MovementAction
	 */
	protected void sequence_LeftMovementAction(ISerializationContext context, LeftMovementAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.LEFT_MOVEMENT_ACTION__LEFTMOVE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.LEFT_MOVEMENT_ACTION__LEFTMOVE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLeftMovementActionAccess().getLeftmoveMovementActionParserRuleCall_1_0(), semanticObject.getLeftmove());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RotatePoints returns LeftRotatePoint
	 *     LeftRotatePoint returns LeftRotatePoint
	 *
	 * Constraint:
	 *     leftdir=FBEnum
	 */
	protected void sequence_LeftRotatePoint(ISerializationContext context, LeftRotatePoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.LEFT_ROTATE_POINT__LEFTDIR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.LEFT_ROTATE_POINT__LEFTDIR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLeftRotatePointAccess().getLeftdirFBEnumEnumRuleCall_2_0(), semanticObject.getLeftdir());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actions returns LeftRotatePoint
	 *     RotateMovementAction returns LeftRotatePoint
	 *
	 * Constraint:
	 *     (leftdir=FBEnum degrees=INT)
	 */
	protected void sequence_LeftRotatePoint_RotateMovementAction(ISerializationContext context, LeftRotatePoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.LEFT_ROTATE_POINT__LEFTDIR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.LEFT_ROTATE_POINT__LEFTDIR));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.ROTATE_POINTS__DEGREES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.ROTATE_POINTS__DEGREES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLeftRotatePointAccess().getLeftdirFBEnumEnumRuleCall_2_0(), semanticObject.getLeftdir());
		feeder.accept(grammarAccess.getRotateMovementActionAccess().getDegreesINTTerminalRuleCall_4_0(), semanticObject.getDegrees());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MarsRoverExpedition returns MarsRoverExpedition
	 *
	 * Constraint:
	 *     (missionlist+=Mission+ tasklist+=Behavior+)
	 */
	protected void sequence_MarsRoverExpedition(ISerializationContext context, MarsRoverExpedition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Actions returns MeasurementAction
	 *     MeasurementAction returns MeasurementAction
	 *
	 * Constraint:
	 *     measure=MAEnum
	 */
	protected void sequence_MeasurementAction(ISerializationContext context, MeasurementAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.MEASUREMENT_ACTION__MEASURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.MEASUREMENT_ACTION__MEASURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMeasurementActionAccess().getMeasureMAEnumEnumRuleCall_0(), semanticObject.getMeasure());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RotatePoints returns MiddleRotatePoint
	 *     MiddleRotatePoint returns MiddleRotatePoint
	 *
	 * Constraint:
	 *     middledir=LREnum
	 */
	protected void sequence_MiddleRotatePoint(ISerializationContext context, MiddleRotatePoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.MIDDLE_ROTATE_POINT__MIDDLEDIR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.MIDDLE_ROTATE_POINT__MIDDLEDIR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMiddleRotatePointAccess().getMiddledirLREnumEnumRuleCall_3_0(), semanticObject.getMiddledir());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actions returns MiddleRotatePoint
	 *     RotateMovementAction returns MiddleRotatePoint
	 *
	 * Constraint:
	 *     (middledir=LREnum degrees=INT)
	 */
	protected void sequence_MiddleRotatePoint_RotateMovementAction(ISerializationContext context, MiddleRotatePoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.MIDDLE_ROTATE_POINT__MIDDLEDIR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.MIDDLE_ROTATE_POINT__MIDDLEDIR));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.ROTATE_POINTS__DEGREES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.ROTATE_POINTS__DEGREES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMiddleRotatePointAccess().getMiddledirLREnumEnumRuleCall_3_0(), semanticObject.getMiddledir());
		feeder.accept(grammarAccess.getRotateMovementActionAccess().getDegreesINTTerminalRuleCall_4_0(), semanticObject.getDegrees());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Mission returns Mission
	 *
	 * Constraint:
	 *     (name=ID behaviorlist+=BehaviorName+ endcondition=EndCondition)
	 */
	protected void sequence_Mission(ISerializationContext context, Mission semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MovementAction returns MovementAction
	 *
	 * Constraint:
	 *     actionenum=ActionEnum
	 */
	protected void sequence_MovementAction(ISerializationContext context, MovementAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.MOVEMENT_ACTION__ACTIONENUM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.MOVEMENT_ACTION__ACTIONENUM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMovementActionAccess().getActionenumActionEnumEnumRuleCall_0(), semanticObject.getActionenum());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actions returns RightMovementAction
	 *     RightMovementAction returns RightMovementAction
	 *
	 * Constraint:
	 *     rightmove=MovementAction
	 */
	protected void sequence_RightMovementAction(ISerializationContext context, RightMovementAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.RIGHT_MOVEMENT_ACTION__RIGHTMOVE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.RIGHT_MOVEMENT_ACTION__RIGHTMOVE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRightMovementActionAccess().getRightmoveMovementActionParserRuleCall_1_0(), semanticObject.getRightmove());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RotatePoints returns RightRotatePoint
	 *     RightRotatePoint returns RightRotatePoint
	 *
	 * Constraint:
	 *     rightdir=FBEnum
	 */
	protected void sequence_RightRotatePoint(ISerializationContext context, RightRotatePoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.RIGHT_ROTATE_POINT__RIGHTDIR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.RIGHT_ROTATE_POINT__RIGHTDIR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRightRotatePointAccess().getRightdirFBEnumEnumRuleCall_2_0(), semanticObject.getRightdir());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actions returns RightRotatePoint
	 *     RotateMovementAction returns RightRotatePoint
	 *
	 * Constraint:
	 *     (rightdir=FBEnum degrees=INT)
	 */
	protected void sequence_RightRotatePoint_RotateMovementAction(ISerializationContext context, RightRotatePoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.RIGHT_ROTATE_POINT__RIGHTDIR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.RIGHT_ROTATE_POINT__RIGHTDIR));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.ROTATE_POINTS__DEGREES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.ROTATE_POINTS__DEGREES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRightRotatePointAccess().getRightdirFBEnumEnumRuleCall_2_0(), semanticObject.getRightdir());
		feeder.accept(grammarAccess.getRotateMovementActionAccess().getDegreesINTTerminalRuleCall_4_0(), semanticObject.getDegrees());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TouchLiteral
	 *     Expression1 returns TouchLiteral
	 *     Expression1.ANDexpression_1_0 returns TouchLiteral
	 *     Expression2 returns TouchLiteral
	 *     Expression2.ORexpression_1_0 returns TouchLiteral
	 *     Expression3 returns TouchLiteral
	 *     TouchLiteral returns TouchLiteral
	 *
	 * Constraint:
	 *     touch=TouchEnum
	 */
	protected void sequence_TouchLiteral(ISerializationContext context, TouchLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.TOUCH_LITERAL__TOUCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.TOUCH_LITERAL__TOUCH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTouchLiteralAccess().getTouchTouchEnumEnumRuleCall_0_0(), semanticObject.getTouch());
		feeder.finish();
	}
	
	
}
